# Binary Exploitation

Eksploitasi biner adalah proses menumbangkan aplikasi yang dikompilasi sedemikian rupa sehingga melanggar beberapa batas kepercayaan dengan cara yang menguntungkan "penyerang". 

## Buffer Overflow
---
Buffer adalah daerah penyimpanan memori yang menyimpan sementara data saat sedang ditransfer dari satu lokasi ke lokasi lain. Buffer overflow (atau buffer overrun) terjadi ketika volume data melebihi kapasitas penyimpanan buffer memori. Akibatnya, program yang mencoba menulis data ke buffer menimpa lokasi memori yang berdekatan.


### Basic Skill 
- Bahasa C
- Bahasa Python
- [Layout Memori ELF](LayoutMemory.md)
- Penggunaan Terminal

### Tools
- [gdb-peda](https://github.com/longld/peda.git)
- IDA Pro 64 & 32
- Text Editor

### Konsep Dasar

![](https://www.imperva.com/learn/wp-content/uploads/sites/13/2018/01/buffer-overflow.png.webp)

Misalnya, buffer untuk kredensial masuk dapat dirancang untuk mengharapkan input ID dan kata sandi sebesar 8 byte, jadi jika transaksi melibatkan input 10 byte (yaitu, 2 byte lebih banyak dari yang diharapkan), program dapat menulis kelebihan data melewati batas buffer. Input yang berlebih tersebut akan masuk kedalam variable yang juga menempel pada variable input sehingga dapat mengubah nilai variable lain atau bahkan membuat program *error*

### Contoh Penerapan
---

Misalkan terdapat program bahasa C sebagai berikut

```
#include <stdio.h>
#include <string.h>

void print(char a, int b, char *c){
	printf("a = %c\n", a);
	printf("b = %d\n", b);
	printf("c = %s\n", c);
}

int main (){

	char a;
	int b;
	char c[8];

	a = 'A';
	b = 0x00004142;
	printf("Try this:  ");
	gets(&c);

	print(a, b, c);


	return 0;
}
```

compile menggunakan gcc

```
gcc -m32 -fno-stack-protector -fno-pie -mpreferred-stack-boundary=2 buff.c -o buff
```

Pada program, terdapat 3 variable yang saling menempel yaitu a, b, dan c.
Kita dapat melihat terdapat input pada variable c menggunakan fungsi *gets*. Fungsi gets merupakan suatu fungsi yang berbahaya untuk digunakan karena tidak memiliki batas input buffer dan tidak melihat tipe data buffer, sehingga fungsi ini akan sangat mudah untuk diekploitasi, terutama overflow. 


mari kita lihat apa yang terjadi jika kita menjalankan program tersebut
```
$ ./buff
Try this:  abc
a = A
b = 16706
c = abc
```
terlihat program berjalan normal. akan tetapi, kita dapat mencoba melakukan buffer overflow dengan input buffer berjumlah >8 bytes, maka
```
$ ./buff 
Try this:  aaaabbbbcccc
a = A
b = 1667457891
c = aaaabbbbcccc

```
dapat dilihat bahwa nilai b berubah, menjadi sangat besar. Hal tersebut terjadi karena variable *c* tidak mampu menyimpan input buffer yang diberi, sehingga buffer yang berlebih tersimpan ke variable b. Hal tersebut yang disebut *BUFFER OVERFLOW*

jika kita lihat variable b menjadi memiliki nilai 1667457891, jika di konversi ke hexa number maka, akan didapat 

```
$ python3 -c "print(hex(1667457891))"
0x63636363
```
atau 4 buah 0x63 jika kita ubah ascii number maka kita akan mendapat huruf 'c', berarti int b menyimpan 'cccc' yang merupakan overflow dari buffer input sebelumnya.
Dikarenakan variable input c hanya memiliki ruang char sebanyak 8 saat dideklarasi.

kita dapat membanyangkan penggambaran memory dari sistem program sebagai berikut 

Bentuk layout stack memory ketika variable a, b, c selesai di deklarasi.
| Variable | Memory Address | MA+0  | MA+1 | MA+2 | MA+3 |
| -------- | -------------- | ---- | ---- | ---- | ---- |
| c        | 0xffffcd78     | /0   | 0x00 | 0x00 | 0x00 |
|          | 0xffffcd7c     | 0x00 | 0x00 | 0x00 | 0x00 |
| b        | 0xffffcd80     | 0x00 | 0x00 | 42 | 41 |
| a        | 0xffffcd84     | 0x00 | 10 | fb | 41 |

Ketika input varible tanpa overflow

| Variable | Memory Address | MA+0  | MA+1 | MA+2 | MA+3 |
| -------- | -------------- | ---- | ---- | ---- | ---- |
| c        | 0xffffcd78     | 41   | 42 | 43 | \0 |
|          | 0xffffcd7c     | 0x00 | 0x00 | 0x00 | 0x00 |
| b        | 0xffffcd80     | 0x00 | 0x00 | 42 | 41 |
| a        | 0xffffcd84     | 0x00 | 10 | fb | 41 |

Ketika input terjadi overflow

| Variable | Memory Address | MA+0  | MA+1 | MA+2 | MA+3 |
| -------- | -------------- | ---- | ---- | ---- | ---- |
| c        | 0xffffcd78     | 41 | 41 | 41 | 41 |
|          | 0xffffcd7c     | 42 | 42 | 42 | 42 |
| b        | 0xffffcd80     | 43 | 43 | 43 | 43 |
| a        | 0xffffcd84     | 0x00 | 10 | fb | 41 |

terlihat terjadi OVERWRITE variable b oleh input buffer variable c sehingga mengubah nilai b menjadi sangat besar


### Buffer Overflow CTF
Pada umumnya soal-soal CTF Buffer overlflow berbentuk file *ELF* yang dijalankan pada server yang dapat diakses melalui *netcat*. Umumnya pada soal juga diberi file *ELF* yang sudah dicompile oleh pembuat soal dan *source code* yang umumnya bahasa C. Yang harus dilakukan adalah *source code* dan *file ELF* yang ada kita melakukan analis input ketika menjalankan *ELF* melalui *netcat*. Jika dalam soal tidak beri source maka kita juga dapat menggunakn gdb-peda atau IDA Pro untuk mengalisisnya.

### Langkah-langkah Pengerjaan
- Analisis *Source Code* yang diberi
- Analisis *ELF* yang diberi
- Analisis variable Input
- Analisis variable overflow
- Menentukan Input
- Menjalankan ELF pada server 

